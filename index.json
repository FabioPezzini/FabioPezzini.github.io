[{"categories":["Vagrant"],"content":"This article shows the basic Vagrant syntax and format.","date":"01-05-2020","objectID":"/vagrant/","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Box ","date":"01-05-2020","objectID":"/vagrant/:1:0","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Download Box It is possible to download from the Vagrant Cloud some images pre-created by users and the hashicorp. From shell just type: vagrant box add hashicorp/precise64 This will download (if not already present in the image list) the box precise64 ie an Ubuntu 12.04 64 bit system. ","date":"01-05-2020","objectID":"/vagrant/:1:1","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Box List To view the list of all the boxes present (downloaded), just type: vagrant box list ","date":"01-05-2020","objectID":"/vagrant/:1:2","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Delete Box To delete a Box from a shell just type: vagrant delete hashicorp/precis64 It is necessary to pass the id of the box to delete the selected box. ","date":"01-05-2020","objectID":"/vagrant/:1:3","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Base Box Vagrant provides BaseBox, that is a minimal image of an OS. An example of a BaseBox that can be found on the VagrantCloud is ubuntu/bionic64. In a BaseBox there are: Package manager SSH SSH user so Vagrant can connect Chef, Puppet, etc. but not strictly required. For advanced users it can be useful to create customized BaseBoxes (that are provider-specific). Since the topic is very large (memory settings, disk, peripherals, …) all the informations are avaible here. Furthermore Vagrant has a suite that allows you to automate the creation of BaseBox called Packer. For most users the boxes on the VagrantCloud are enough. ","date":"01-05-2020","objectID":"/vagrant/:1:4","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Initialize Vagrant Box Each project in Vagrant must be placed in a personal directory, and to work with it you need to move to the chosen project. It is necessary to create a new directory, move inside it and initialize the project mkdir project1 cd project1 vagrant init hashicorp/precise64 This will create a Vagrantfile file containing all the characteristics of the project, in this case it will be: Vagrant.configure (\"2\") do | config | config.vm.box = \"hashicorp/precise64\" end Now all we have is a VM (not started) based on Ubuntu 12.04 64 bit. Here are presented some useful flag: Create a minimal Vagrantfile (no comments or helpers): vagrant init -m hashicorp/precise64 Create a new Vagrantfile, overwriting the one at the current path: vagrant init -f hashicorp/precise64 Create a Vagrantfile with the specific box, from the specific box URL: vagrant init my-company-box https://boxes.company.com/my-company.box Create a Vagrantfile, locking the box to a version constraint: vagrant init --box-version '\u003e 0.1.5' hashicorp/precise64 ","date":"01-05-2020","objectID":"/vagrant/:2:0","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Management Vagrant Project Vagrant provides several commands to interact with the VMs: Stop the VM: vagrant halt if it is used in a folder containing several VMs are all stopped unless unless the id of the VM to be stopped is passed. Suspend the VM: vagrant suspend if it is used in a folder containing several VMs are all suspended unless the id of the VM to be suspended is passed. Delete the VM: vagrant destroy this command is a bit different from the previous ones, in fact if executed inside a folder containing a project with multiple VMs, from there possibility to choose in an interactive way which to delete and which not; instead if the id is specified it is possible to delete the VM wherever it is. Interact with the VM: After the VM has been activated, an SSH session can be started moving within the project directory and declaring the hostname of the VM to use cd project1 vagrant ssh From now on you will have control over the VM, to close the session just press CTRL + D or logout Shared folders It is possible to share resources between the host machine and the guest machine (VM) if they are contained within of the folder containing the VagrantFile, to verify it once the SSH session with the VM is open, just type ls /vagrant All that is present in the folder is visible either from the host to the guest. ","date":"01-05-2020","objectID":"/vagrant/:3:0","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Start Vagrant Project ","date":"01-05-2020","objectID":"/vagrant/:4:0","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"First Start If the project has just been initialized to start the VM you need to move inside the project folder and start it: cd project1 vagrant up In this way provisioning is forced (performed through Shell, Chef, Puppet, …) and the guest system is started. ","date":"01-05-2020","objectID":"/vagrant/:4:1","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Generic Start If the project has already been started previously is recommend for start it using the command: cd project1 vagrant reload This command allows the machine to start without them coming perform the reloading operations on the provisioning, if they have been carried out provisioning operations to make them effective is necessary to launch: cd project1 vagrant reload --provision ","date":"01-05-2020","objectID":"/vagrant/:4:2","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Status Vagrant Project To view the status of the VMs there are two commands to execute in different positions: vagrant status (local) vagrant global status (global) The status are three: not created running stopped ","date":"01-05-2020","objectID":"/vagrant/:5:0","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Vagrant Status This command returns the status of the vm: cd project1 vagrant status It will return the status of the machines based on where it is executed (eg project1): ","date":"01-05-2020","objectID":"/vagrant/:5:1","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Vagrant Global Status This command allows us to view the status of all the VMs previously created. Often the status is not updated so is recommended to force the reload of the status: vagrant global-status --prune ","date":"01-05-2020","objectID":"/vagrant/:5:2","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Networking Configurations Each of the networking adapters can be separately configured to operate in one of the following modes: NAT: abbreviation of Network Address Translation, a VM with NAT acts like a real computer that connects to the Internet through a router, in this case the Virtualbox Networking Engine. Used for example, for browse Web,download file, view email,… inside the guest. NAT Network: Virtualbox behaves like a DHCP server by assigning an IP to the guest but from a different address space. Shortly is a type of internal network that allow outbounds connections. N.B = create a NAT Network first, in VirtualBox click File-\u003ePreferences-\u003eNetwork-\u003eNAT Networks, assign a name a CIDR and entering support for DHCP. Bridged: with this configuration Virtualbox uses a network card on the host system and exchange network packets directly avoidind the host operating system’s network stack. N.B = In the VM Network settings you need to specify which network card you want to use. Internal: is protected network that is not accessible to the internet in general. Host Only: VMs in this network can connect to each other and the same would be reachable via your host machine but the VMs would not be able to access the outside external network. Generic: rarely used modes which share the same generic network interface, by allowing the user to select a driver which can be included with Oracle VM VirtualBox or be distributed in an extension pack. Question NAT NAT Network Bridged Internal Host Only Can VM connect to Host? Yes Yes Yes No Yes Can Host connect to Vm? PF PF Yes No Yes Can VM connect to external network? Yes Yes Yes No No Can VM connect another VMS in the same network? No Yes Yes Yes Yes Can other computers on the external network connect to VM? PF PF Yes No No PF means that is not default but can achieve that doing a port forward More info from here ","date":"01-05-2020","objectID":"/vagrant/:6:0","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Vagrantfiles VagrantFile is the heart of Vagrant, it allows us to define all project specifications. For each project it is allowed just a Vagrant file. N.B = if you want to use the Vagrant files commented below it is necessary to rename the files in Vagrantfile ","date":"01-05-2020","objectID":"/vagrant/:7:0","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Base Vagrantfile This Vagrantfile is the standard one created at the init of the project. This Vagrantfile create a single VM with a specific box. ","date":"01-05-2020","objectID":"/vagrant/:7:1","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Networking Settings In Vagrant the adapter n.1 (eth0) is always a NAT adapter because is used from the Host to communicate with the Guest via SSH. Private Network Vagrant private networks allow you to access your guest machine by some address that is not publicly accessible from the global Internet. Host Only: By default, private networks are host-only networks, because those are the easiest to work with. Behind the scene, VirtualBox creates a new virtual interface (“loopback”) on the host which appears next to the existing network interfaces. VirtualBox even provide a built-in DHCP server for host-only networking if no static IPs have been assigned. Internal Network: The Vagrant VirtualBox provider supports using the private network as a VirtualBox internal network. By default, private networks are host-only networks, because those are the easiest to work with. However, internal networks can be enabled as well. Public Network Vagrant public networks are less private than private networks, and the exact meaning actually varies from provider to provider, hence the ambiguous definition. The idea is that while private networks should never allow the general public access to your machine, public networks can. It’s a Bridged Network. Bridged Forwarded Ports Vagrant forwarded ports allow you to access a port on your host machine and have all data forwarded to a port on the guest machine, over either TCP or UDP. For example: If the guest machine is running a web server listening on port 80, you can make a forwarded port mapping to port 8080 (or anything) on your host machine. You can then open your browser to localhost:8080 and browse the website, while all actual network data is being sent to the guest. ","date":"01-05-2020","objectID":"/vagrant/:7:2","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Provider Settings While well-behaved Vagrant providers should work with any Vagrantfile with sane defaults, providers generally expose unique configuration options so that you can get the most out of each provider. This provider-specific configuration is done within the Vagrantfile in a way that is portable, easy to use, and easy to understand. VirtualBox: VBoxManage is a utility that can be used to make modifications to VirtualBox virtual machines from the command line. Vagrant exposes a way to call any command against VBoxManage just prior to booting the machine. Here several commands are presented. ","date":"01-05-2020","objectID":"/vagrant/:7:3","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Multi Machine Vagrant is able to define and control multiple guest machines per Vagrantfile. This is known as a “multi-machine” environment. These machines are generally able to work together or are somehow associated with each other. Multi with same Provider This will create a lab with 3 machine, ubonda has access to internet with a bridged interface; the other two are in a private network and can communicate only with each other but not with ubonda. It is necessary to declare a virtualbox__intnet: true to isolate the two machine or ubonda will connect to them. Multi with different Provider In this lab I will use 3 machines: ubonda a vm created with Virtualbox that can navigate through internet and connect to slave-connector slave-connector a container created with Docker that is in a subnet with another container slaveand can communicate with ubonda slave a container created with Docker that is in a subnet with slave-connector First of all create a docker network to connect ubonda with slave-connector: docker network create bridge2 --gateway=192.168.50.1 --subnet=192.168.50.1/24 Then check the network id just created: docker network ls Finally put the id in the public network in the Vagrantfile. Remember to use the docker_network__internal: true to create a private network for the containers. ","date":"01-05-2020","objectID":"/vagrant/:7:4","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Provisioning Provisioners in Vagrant allow you to automatically install software, alter configurations, and more on the machine as part of the vagrant up process. This is useful since boxes typically are not built perfectly for your use case. Of course, if you want to just use vagrant ssh and install the software by hand, that works. But by using the provisioning systems built-in to Vagrant, it automates the process so that it is repeatable. Shell Provisioning: The Vagrant Shell provisioner allows you to upload and execute a script within the guest machine. Shell provisioning is ideal for users new to Vagrant who want to get up and running quickly. Puppet Provisioning: N.B = puppet need to be installed in the guest vm. By default, Vagrant will configure Puppet to look for manifests in the “manifests” folder relative to the project root, and will use the “default.pp” manifest as an entry-point. In my case i use ubonda.pp in this file you have to insert the modules present in the modules folder and that you want to install. Every modules need to contain an init.pp, a file containing all the services, packages and commands to be executed, the syntax is in Puppet Language. ","date":"01-05-2020","objectID":"/vagrant/:7:5","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Vagrant"],"content":"Questions It is possible to use two or more provider on a single Vagrantfile different providers? Yes,for example you can use VirtualBox and Docker as provider, remember to start the docker service or vagrant will use virtualbox as default provider instead of Virtualbox. It is possible to use a single VM with two providers different at the same time? No, trying to do so returns an error that explains that the function will be introduced in later versions. Convert the Docker image into a Vagrant box? It is possible to do so, here there is a tutorial ","date":"01-05-2020","objectID":"/vagrant/:8:0","tags":["Vagrant","VM"],"title":"Vagrant","uri":"/vagrant/"},{"categories":["Chef-Solo"],"content":"This article shows the basic Chef-Solo syntax and format.","date":"07-05-2020","objectID":"/chef/","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Terminology Node: The deployment target - this is what configured, has chef-client or chef-solo installed Chef Client: a command line tool that configures servers. Chef Server: This is where all your code resides. It also contains all the information about nodes. N.B = combined with a Node when using Chef-Solo. Recipes - a single file of Ruby code that contains commands to run on a node. Resources - a node’s resources include files, directories, users and services. Cookbook - a collection of Chef recipes. Role: reusable configuration for multiple nodes. Attribute: variables that are passed through Chef and used in recipes and templates. Template: a file with placeholders for attributes, used to create configuration files. Chef-Solo: open source version on Chef Client, doesn’t require access to Chef Server, requires that a cookbook be on the same physical disk as the node. Knife-Solo: provides interface between local Chef-Repo and Chef Server. Berkshelf: manages cookbooks and their dependencies (like bundler for rubygems). Kitchen: chef-repo, located on workstation. WorkStation: local machine aka your laptop. This is where you write your code which is then pushed to your chef server. N.B = push to a Node with Chef-Solo. ","date":"07-05-2020","objectID":"/chef/:1:0","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Initialize the Project First create a folder, which will contain all our Chef kitchen: mkdir example cd example Use a bundler to install some gems or install it via shell gem install knife-solo gem install librarian-chef Create a new Kitchen in current directory: knife solo init . This will create a file structure like this: .chef/ : stores .pem files and knife.rb cookbooks/ : vendor cookbooks installed with librarian data_bags/ : data bags environments/ : environments nodes/ : nodes roles/ : roles site-cookbooks/ : custom cookbooks Some useful recap about the used gems: ","date":"07-05-2020","objectID":"/chef/:2:0","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Knife Provides interface between local Chef Repo and Chef Server. Knife-Solo adds 5 subcommands to the classic Knife: knife solo init (create a new kitchen) knife solo prepare (install chef-solo on target host) knife solo cook (upload current kitchen to target host and run chef-solo there) knife solo bootstrap (prepare + cook) knife solo clean (remove uploaded kitchen from target host) ","date":"07-05-2020","objectID":"/chef/:2:1","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Librarian (or BerkShelf) They manages cookbooks and their dependencies (like bundler for rubygems). Librarian-Chef can resolve and fetch third-party, publicly-released cookbooks, and install them into your infrastructure repository. It can also source cookbooks directly from their own source control repositories. Librarian-Chef takes over your cookbooks/ directory and manages it for you based on your Cheffile. Your Cheffile becomes the authoritative source for the cookbooks your infrastructure repository depends on. You should not modify the contents of your cookbooks/ directory when using Librarian-Chef. If you have cookbooks which are, rather than being separate projects, inherently part of your infrastructure repository, then they should go in a separate directory, like your site-cookbooks/ directory, and you do not need to use Librarian-Chef to manage them. Every infrastructure repository that uses Librarian-Chef will have a file named Cheffile in the root directory of that repository. ","date":"07-05-2020","objectID":"/chef/:2:2","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Kitchen It is a Chef Repo, is located on a workstation and uploaded to a node when using Chef-Solo (or to a Chef Server) ","date":"07-05-2020","objectID":"/chef/:2:3","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Resource A Chef resource describes one part of the system, such as a file, a template, or a package. A Chef recipe is a file that groups related resources, such as everything needed to configure a web server, database server, or a load balancer. There are 2 types of resources: Platform resource: are avaible in Chef Client directly, doesn’t require a cookbook Custom resource: must be defined in a resource file located in the resources/ folder; used in a Recipe in the same way as a platform resource Some examples here ","date":"07-05-2020","objectID":"/chef/:3:0","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Platform Resource Syntax: TYPE 'NAME' do PROPERTY_NAME 'PROPERTY_VALUE' action :TYPE_OF_ACTION end type: platform resource types: package, template, service,… name: for platform resources dealing with files (directory, cookbook_file, etc.) this is usually the path of corresponding file on chef node. Popular platform resources: Resource Desc script execute script using specified interpretor bash execute script using Bash interpretor ruby execute script using Ruby interpretor link create sym or hard links directory manage directories cookbook_file transfer files from subdirectory of files/ template transfer files from subdirectory of templates/ package install package (rpm, deb, etc.) gem_package install gem system-wide chef_gem install gem into the instance of Ruby dedicated to chef-client cron modify cron entries user manage users ","date":"07-05-2020","objectID":"/chef/:3:1","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Custom Resource A brief introduction to the custom resource. It declares properties of custom resource, loads current properties if resource already exists,defines all resource actions, Syntax: resource_name :httpd property :instance_name, String, name_property: true property :name, RubyType, default: 'value' default_action :action_2 load_current_value do # some Ruby end action :action_1 do # a mix of built-in Chef resources and Ruby end action :action_2 do # a mix of built-in Chef resources and Ruby end resource_name overrides default resource name name_property: true makes this property to use resource name as its value load_current_value block loads current values for all properties default_action overrides default action ","date":"07-05-2020","objectID":"/chef/:3:2","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Recipes A Chef cookbook is comprised of recipes that a nodes desired state. Recipes are written in Ruby and contain information about everything that needs to be run, changed, or created on a node. Recipes work as a collection of resources that determine the configuration or policy of a node, with resources being a configuration element of the recipe. For a node to run a recipe, it must be on that node’s run list. The dafault recipe (is necessary in every cookbook) is default.rb. Recipe can include other recipes from other cookbooks using include_recipe method: include_recipe 'apache2::mod_ssl' Included recipe must be declared as dependency in metadata.rb: depends 'apache2' Here you can find an axemple of a recipe that is part of Chef’s Vim cookbook. It is in charge of installing the required Vim package based on a node’s Linux distribution. ","date":"07-05-2020","objectID":"/chef/:4:0","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Cookbooks A cookbook is a collection of Chef Recipes. All cookbooks like a Chef are written in Ruby. Here you can find an example about the structure of a cookbook. ","date":"07-05-2020","objectID":"/chef/:5:0","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Vendor Cookbooks Using Librarian Create a Cheffile in the directory of the project: librarian-chef init Add dependencies and their sources to the Cheffile: site 'https://supermarket.getchef.com/api/v1' cookbook 'ntp' cookbook 'timezone', '0.0.1' cookbook 'rvm', :git =\u003e 'https://github.com/fnichol/chef-rvm', :ref =\u003e 'v0.7.1' cookbook 'cloudera', :path =\u003e 'vendor/cookbooks/cloudera-cookbook' Then run: librarian-chef install This command looks at each cookbook declaration and fetches the cookbook from the source specified, or from the default source if none is provided. Each cookbook is inspected, its dependencies are determined, and each dependency is also fetched. For example, if you declare cookbook ‘nagios’, which depends on other cookbooks such as ‘php’, then those other cookbooks including ‘php’ will be fetched. This goes all the way down the chain of dependencies. This command then copies all of the fetched cookbooks into your cookbooks/ directory, overwriting whatever was there before. Using BerkShelf In the directory of the project create a Berksfile and inside it write: cookbook 'apache2' Then run this to install cookbook globally into ~/.berkshelf/cookbooks/: berks install berks upload Or run this to install cookbook both locally into cookbooks/ and globally into ~/.bershelf/cookbooks/: berks vendor cookbooks ","date":"07-05-2020","objectID":"/chef/:5:1","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Site Cookbooks Let’s create our cookbook. Our custom cookbooks should be in the folder site-cookbooks/ (the folder cookbooks/ is used for vendor cookbooks and managed by librarian or berkshelf) Create a custom Cookbook: cd site-cookbooks/ knife cookbook create Tomatoes Then configure and add your service using the Recipes,Attributes,DataBags ecc. Lastly add the new recipe in the run_list of the project Node. ","date":"07-05-2020","objectID":"/chef/:5:2","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Nodes Nodes are configured in node files for chef-solo only; chef-client interacts with chef server to retrieve node configuration. Consequently, node-specific attributes must be located in a JSON file on the target system, a remote location, or a web server on the local network. Nodes contains node-specific attributes and run-list Nodes represents machine (physical, virtual, etc.) Nodes separate JSON file for each node in nodes/ Node file name (as a rule): DOMAIN.json Create a DOMAIN.json in the nodes folder and write inside it: { run_list: [ 'role[base]', 'recipe[apache2]' ] } N.B = run_list is the main key in a node file, the default.rb is executed when only cookbook name is specified without specific recipe. Run lists define which recipes a node will use. The run list is an ordered list of all roles and recipes that the chef-client needs to pull from the Chef server to run on a node. Roles are used to define patterns and attributes across nodes. N.B = We can use the run_list of a specific role declaring it in the run_list of the node. ","date":"07-05-2020","objectID":"/chef/:6:0","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Roles In most cases you project contain several servers with the same configuration. For example, you can have several web servers and one load balancer, which balance on this web servers. Or you can have several database or queue servers with identical configuration. In this case, it is very hard way to clone each server by nodes, because you need copy all attributes from one node to another. Maintain a system with such nodes also will be hard: you will have to modify the “n” number of nodes to change some attribute value. We can use role! A role provides a means of grouping similar features of similar nodes, providing a mechanism for easily composing sets of functionality. A Role is a server template (web, database, etc.), it contains server-specific run-list and attributes. Need to create separate JSON file for each role in roles/. The json file required: name : unique name (usually the same as file name) description chef_type : role json_class : Chef::Role run_list : role-specific run-list (may include other roles). An example of a role file can be found Here ","date":"07-05-2020","objectID":"/chef/:7:0","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Data Bags Data Bag are global variable stored as JSON data; it is used to store sensitive data (credentials, etc.). data bag consists of data bag items: DATA_BAG/DATA_BAG_ITEM.json The structure is like this: name : unique name (usually the same as file name) chef_type : data_bag_item json_class : Chef::DataBagItem data_bag : data bag name raw_data : attributes of data bag item (id attribute is required) Example here ","date":"07-05-2020","objectID":"/chef/:8:0","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Examples ","date":"07-05-2020","objectID":"/chef/:9:0","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Example Cookbook ","date":"07-05-2020","objectID":"/chef/:9:1","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Structure A cookbook can have: metadata.rb - a file, which contain all information about the cookbook (name, dependencies). name \"nginx\" maintainer \"Opscode, Inc.\" maintainer_email \"cookbooks@opscode.com\" license \"Apache 2.0\" description \"Installs and configures nginx\" version \"1.1.2\" recipe \"nginx\", \"Installs nginx package and sets up configuration with Debian apache style with sites-enabled/sites-available\" recipe \"nginx::source\", \"Installs nginx from source and sets up configuration with Debian apache style with sites-enabled/sites-available\" %w{ ubuntu debian centos redhat amazon scientific oracle fedora }.each do |os| supports os end %w{ build-essential }.each do |cb| depends cb end depends 'ohai', '\u003e= 1.1.2' %w{ runit bluepill yum }.each do |cb| recommends cb end attributes - Attributes define specific values about a node and its configuration and are used by the Chef client to apply those attributes to nodes via its attribute list. The chef client can receive attributes from nodes, attribute files, recipes, environments, and roles. Often attributes are used in conjunction with templates and recipes to define settings. : default['nginx']['version'] = \"1.2.3\" default['nginx']['dir'] = \"/etc/nginx\" default['nginx']['log_dir'] = \"/var/log/nginx\" default['nginx']['binary'] = \"/usr/sbin/nginx\" files - These are static files that can be uploaded to nodes. Files can be configuration and set-up files, scripts, website files. For example, you may have a recipe that uses an index.php file. You can use a cookbook_file resource block within a recipe to create the file on a node. All static files should be stored in a cookbook’s files directory recipes - a folder, which contain all recipes from this cookbook. Each recipe is in a separate Ruby file templates - are embedded Ruby files (.erb) that are used to dynamically create static text files. To use a template within a cookbook, you must declare a template resource in a recipe and include a corresponding .erb template file in a template subdirectory. Your template resource can contain variables that will then be used by the template to dynamically provide those values based on a nodes particular context. ","date":"07-05-2020","objectID":"/chef/:10:0","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Example Databag { \"name\":\"data_bag_item_dogs_tibetanspaniel\", \"json_class\":\"Chef::DataBagItem\", \"chef_type\":\"data_bag_item\", \"data_bag\":\"dogs\", \"raw_data\": { \"description\":\"small dog that likes to sit in windows\", \"id\":\"tibetanspaniel\" } } ","date":"07-05-2020","objectID":"/chef/:10:1","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Example Recipe vim_base_pkgs = value_for_platform_family( %w(debian arch) =\u003e ['vim'], %w(rhel fedora) =\u003e ['vim-minimal', 'vim-enhanced'], 'default' =\u003e ['vim'] ) package vim_base_pkgs package node['vim']['extra_packages'] unless node['vim']['extra_packages'].empty? ","date":"07-05-2020","objectID":"/chef/:10:2","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Example Resource Platform Resource Create a file in the tmp/ folder named hi and set its content: file '/tmp/hi' do content 'hi world' end Delete a file named as hi in the tmp/ folder: file '/tmp/hi' do action :delete end Create a directory named as something and set some permissions: directory '/tmp/something' do owner 'root' group 'root' mode 00755 action :create end This is a Recipe, it is shown to highlight the differences in types of resources (package, services, built in). It consists of installing and setting up different services. N.B = calling a package will install it apt_update 'Update the apt cache daily' do frequency 86_400 action :periodic end package 'apache2' service 'apache2' do supports status: true action [:enable, :start] end file '/var/www/html/index.html' do content '\u003chtml\u003e \u003cbody\u003e \u003ch1\u003ehello world\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e' end Custom Resource Homepage is a property that sets the default HTML for the index.html file with a default value. The action block uses the built-in collection of resources to tell Chef Infra Client how to install Apache, start the service, and then create the contents of the file located at /var/www/html/index.html . action :create is the default resource, because it is listed first; action :delete must be called specifically (because it is not the default resource) property :homepage, String, default: '\u003ch1\u003eHello world!\u003c/h1\u003e' action :create do package 'httpd' service 'httpd' do action [:enable, :start] end file '/var/www/html/index.html' do content new_resource.homepage end end action :delete do package 'httpd' do action :delete end end ","date":"07-05-2020","objectID":"/chef/:10:3","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":["Chef-Solo"],"content":"Example Role { \"name\": \"base\", \"chef_type\": \"role\", \"json_class\": \"Chef::Role\", \"description\": \"The base role for systems\", \"run_list\": [ \"recipe[apt]\", \"recipe[sudo]\", \"recipe[sysctl]\", \"recipe[nginx::source]\", \"recipe[Tomatoes]\" ] } ","date":"07-05-2020","objectID":"/chef/:10:4","tags":["Chef","Orchestration","DevOps"],"title":"Chef-Solo","uri":"/chef/"},{"categories":null,"content":"Fabio Pezzini CV pezzinif@gmail.com - Italy ","date":"01-01-0001","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Education 2019-2021 (expected) MSc, Computer Engineering; University of Pavia (Pavia) 2016-2019 BSc, Electronic and Computer Engineering; University of Pavia (Pavia) Thesis title: Development of a software to manage hybrid virtual environments ","date":"01-01-0001","objectID":"/about/:0:1","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Work Experience Mar 2014 - Oct 2017, Video Content Creator, Machinima Inc. Creation of video content and animation in the entertainment industries. Detailed achievements: Learned some advanced video creation softwares (Adobe Premiere Pro, Sony Vegas Pro) Learned an advanced graphics editor software (Photoshop) Knowledgebase about 3D modeling software (Cinema4D, Blender) ","date":"01-01-0001","objectID":"/about/:0:2","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Technical Skills Programming Languages: C, Java, JavaScript, Python, MIPS Assembly, MATLAB Databases: MySQL, MongoDB Operating Systems: Windows, Linux Software: Adobe Premiere Pro, Adobe Photoshop, Sony Vegas Pro, Blender, Office Suite ","date":"01-01-0001","objectID":"/about/:0:3","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Personal Skills Human Languages: Mother Tongue: Italian Language Understanding Speaking Writing English B2 B2 B2 Passion and ability to learning new languages and technologies. Good communication skills gained through my experience as video content creator. Knowledge of some network security tools. ","date":"01-01-0001","objectID":"/about/:0:4","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":" ViugrUp\r\rDescription\rThe application allows the creation of complex hybrid virtual environments, with Docker containers and VMs.\rIt is possible to install some applications automatically from the command line or through an XML file.\rThe project was designed to practice about creating and exploiting vulnerable virtual machines for CTFs\r\r\rLanguagesSource\r\rRuby\rGitHub\r\r","date":"01-01-0001","objectID":"/projects/:0:0","tags":null,"title":"","uri":"/projects/"}]